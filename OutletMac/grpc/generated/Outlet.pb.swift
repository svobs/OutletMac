// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Outlet.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// nothing
public struct Outlet_Backend_Daemon_Grpc_Generated_Empty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_ConfigEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String = String()

  public var val: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_GetConfig_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var configKeyList: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_GetConfig_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var configList: [Outlet_Backend_Daemon_Grpc_Generated_ConfigEntry] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_PutConfig_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var configList: [Outlet_Backend_Daemon_Grpc_Generated_ConfigEntry] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// nothing
public struct Outlet_Backend_Daemon_Grpc_Generated_PutConfig_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_GetFilter_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var treeID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_GetFilter_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var filterCriteria: Outlet_Backend_Daemon_Grpc_Generated_FilterCriteria {
    get {return _filterCriteria ?? Outlet_Backend_Daemon_Grpc_Generated_FilterCriteria()}
    set {_filterCriteria = newValue}
  }
  /// Returns true if `filterCriteria` has been explicitly set.
  public var hasFilterCriteria: Bool {return self._filterCriteria != nil}
  /// Clears the value of `filterCriteria`. Subsequent reads from it will return its default value.
  public mutating func clearFilterCriteria() {self._filterCriteria = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _filterCriteria: Outlet_Backend_Daemon_Grpc_Generated_FilterCriteria? = nil
}

public struct Outlet_Backend_Daemon_Grpc_Generated_UpdateFilter_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var treeID: String = String()

  public var filterCriteria: Outlet_Backend_Daemon_Grpc_Generated_FilterCriteria {
    get {return _filterCriteria ?? Outlet_Backend_Daemon_Grpc_Generated_FilterCriteria()}
    set {_filterCriteria = newValue}
  }
  /// Returns true if `filterCriteria` has been explicitly set.
  public var hasFilterCriteria: Bool {return self._filterCriteria != nil}
  /// Clears the value of `filterCriteria`. Subsequent reads from it will return its default value.
  public mutating func clearFilterCriteria() {self._filterCriteria = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _filterCriteria: Outlet_Backend_Daemon_Grpc_Generated_FilterCriteria? = nil
}

/// nothing
public struct Outlet_Backend_Daemon_Grpc_Generated_UpdateFilter_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_RemoveExpandedRow_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nodeUid: UInt32 = 0

  public var treeID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// nothing
public struct Outlet_Backend_Daemon_Grpc_Generated_RemoveExpandedRow_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_GetRowsOfInterest_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var treeID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_GetRowsOfInterest_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var expandedRowUidSet: [UInt32] = []

  public var selectedRowUidSet: [UInt32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_GetLastPendingOp_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nodeUid: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_DownloadFromGDrive_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nodeUid: UInt32 = 0

  public var requestorID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_GetLastPendingOp_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userOp: Outlet_Backend_Daemon_Grpc_Generated_UserOp {
    get {return _userOp ?? Outlet_Backend_Daemon_Grpc_Generated_UserOp()}
    set {_userOp = newValue}
  }
  /// Returns true if `userOp` has been explicitly set.
  public var hasUserOp: Bool {return self._userOp != nil}
  /// Clears the value of `userOp`. Subsequent reads from it will return its default value.
  public mutating func clearUserOp() {self._userOp = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userOp: Outlet_Backend_Daemon_Grpc_Generated_UserOp? = nil
}

/// nothing
public struct Outlet_Backend_Daemon_Grpc_Generated_Subscribe_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// nothing
public struct Outlet_Backend_Daemon_Grpc_Generated_GetOpExecPlayState_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_ToggleUiEnablement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var enable: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_GenerateMergeTree_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var treeIDLeft: String = String()

  public var treeIDRight: String = String()

  public var changeListLeft: [Outlet_Backend_Daemon_Grpc_Generated_SPIDNodePair] = []

  public var changeListRight: [Outlet_Backend_Daemon_Grpc_Generated_SPIDNodePair] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_DragDrop_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var srcTreeID: String = String()

  public var dstTreeID: String = String()

  public var srcSnList: [Outlet_Backend_Daemon_Grpc_Generated_SPIDNodePair] = []

  public var dstSn: Outlet_Backend_Daemon_Grpc_Generated_SPIDNodePair {
    get {return _dstSn ?? Outlet_Backend_Daemon_Grpc_Generated_SPIDNodePair()}
    set {_dstSn = newValue}
  }
  /// Returns true if `dstSn` has been explicitly set.
  public var hasDstSn: Bool {return self._dstSn != nil}
  /// Clears the value of `dstSn`. Subsequent reads from it will return its default value.
  public mutating func clearDstSn() {self._dstSn = nil}

  public var isInto: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _dstSn: Outlet_Backend_Daemon_Grpc_Generated_SPIDNodePair? = nil
}

public struct Outlet_Backend_Daemon_Grpc_Generated_RefreshSubtree_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nodeIdentifier: Outlet_Backend_Daemon_Grpc_Generated_NodeIdentifier {
    get {return _nodeIdentifier ?? Outlet_Backend_Daemon_Grpc_Generated_NodeIdentifier()}
    set {_nodeIdentifier = newValue}
  }
  /// Returns true if `nodeIdentifier` has been explicitly set.
  public var hasNodeIdentifier: Bool {return self._nodeIdentifier != nil}
  /// Clears the value of `nodeIdentifier`. Subsequent reads from it will return its default value.
  public mutating func clearNodeIdentifier() {self._nodeIdentifier = nil}

  public var treeID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nodeIdentifier: Outlet_Backend_Daemon_Grpc_Generated_NodeIdentifier? = nil
}

public struct Outlet_Backend_Daemon_Grpc_Generated_RefreshSubtreeStats_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rootUid: UInt32 = 0

  public var treeID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_DeleteSubtree_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nodeUidList: [UInt32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_ErrorOccurred {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var msg: String = String()

  public var secondaryMsg: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_UidContainer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_StartDiffTrees_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var treeIDLeft: String = String()

  public var treeIDRight: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_StartDiffTrees_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var treeIDLeft: String = String()

  public var treeIDRight: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// nothing
public struct Outlet_Backend_Daemon_Grpc_Generated_DragDrop_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_SignalMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sigInt: UInt32 = 0

  public var sender: String = String()

  public var signalData: Outlet_Backend_Daemon_Grpc_Generated_SignalMsg.OneOf_SignalData? = nil

  public var empty: Outlet_Backend_Daemon_Grpc_Generated_Empty {
    get {
      if case .empty(let v)? = signalData {return v}
      return Outlet_Backend_Daemon_Grpc_Generated_Empty()
    }
    set {signalData = .empty(newValue)}
  }

  public var errorOccurred: Outlet_Backend_Daemon_Grpc_Generated_ErrorOccurred {
    get {
      if case .errorOccurred(let v)? = signalData {return v}
      return Outlet_Backend_Daemon_Grpc_Generated_ErrorOccurred()
    }
    set {signalData = .errorOccurred(newValue)}
  }

  public var displayTreeUiState: Outlet_Backend_Daemon_Grpc_Generated_DisplayTreeUiState {
    get {
      if case .displayTreeUiState(let v)? = signalData {return v}
      return Outlet_Backend_Daemon_Grpc_Generated_DisplayTreeUiState()
    }
    set {signalData = .displayTreeUiState(newValue)}
  }

  public var playState: Outlet_Backend_Daemon_Grpc_Generated_PlayState {
    get {
      if case .playState(let v)? = signalData {return v}
      return Outlet_Backend_Daemon_Grpc_Generated_PlayState()
    }
    set {signalData = .playState(newValue)}
  }

  public var uiEnablement: Outlet_Backend_Daemon_Grpc_Generated_ToggleUiEnablement {
    get {
      if case .uiEnablement(let v)? = signalData {return v}
      return Outlet_Backend_Daemon_Grpc_Generated_ToggleUiEnablement()
    }
    set {signalData = .uiEnablement(newValue)}
  }

  public var node: Outlet_Backend_Daemon_Grpc_Generated_Node {
    get {
      if case .node(let v)? = signalData {return v}
      return Outlet_Backend_Daemon_Grpc_Generated_Node()
    }
    set {signalData = .node(newValue)}
  }

  public var srcDstNodeList: Outlet_Backend_Daemon_Grpc_Generated_SrcDstNodeList {
    get {
      if case .srcDstNodeList(let v)? = signalData {return v}
      return Outlet_Backend_Daemon_Grpc_Generated_SrcDstNodeList()
    }
    set {signalData = .srcDstNodeList(newValue)}
  }

  public var statusMsg: Outlet_Backend_Daemon_Grpc_Generated_StatusMsg {
    get {
      if case .statusMsg(let v)? = signalData {return v}
      return Outlet_Backend_Daemon_Grpc_Generated_StatusMsg()
    }
    set {signalData = .statusMsg(newValue)}
  }

  public var downloadMsg: Outlet_Backend_Daemon_Grpc_Generated_DownloadMsg {
    get {
      if case .downloadMsg(let v)? = signalData {return v}
      return Outlet_Backend_Daemon_Grpc_Generated_DownloadMsg()
    }
    set {signalData = .downloadMsg(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_SignalData: Equatable {
    case empty(Outlet_Backend_Daemon_Grpc_Generated_Empty)
    case errorOccurred(Outlet_Backend_Daemon_Grpc_Generated_ErrorOccurred)
    case displayTreeUiState(Outlet_Backend_Daemon_Grpc_Generated_DisplayTreeUiState)
    case playState(Outlet_Backend_Daemon_Grpc_Generated_PlayState)
    case uiEnablement(Outlet_Backend_Daemon_Grpc_Generated_ToggleUiEnablement)
    case node(Outlet_Backend_Daemon_Grpc_Generated_Node)
    case srcDstNodeList(Outlet_Backend_Daemon_Grpc_Generated_SrcDstNodeList)
    case statusMsg(Outlet_Backend_Daemon_Grpc_Generated_StatusMsg)
    case downloadMsg(Outlet_Backend_Daemon_Grpc_Generated_DownloadMsg)

  #if !swift(>=4.1)
    public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_SignalMsg.OneOf_SignalData, rhs: Outlet_Backend_Daemon_Grpc_Generated_SignalMsg.OneOf_SignalData) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.empty, .empty): return {
        guard case .empty(let l) = lhs, case .empty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.errorOccurred, .errorOccurred): return {
        guard case .errorOccurred(let l) = lhs, case .errorOccurred(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.displayTreeUiState, .displayTreeUiState): return {
        guard case .displayTreeUiState(let l) = lhs, case .displayTreeUiState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.playState, .playState): return {
        guard case .playState(let l) = lhs, case .playState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiEnablement, .uiEnablement): return {
        guard case .uiEnablement(let l) = lhs, case .uiEnablement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.node, .node): return {
        guard case .node(let l) = lhs, case .node(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.srcDstNodeList, .srcDstNodeList): return {
        guard case .srcDstNodeList(let l) = lhs, case .srcDstNodeList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.statusMsg, .statusMsg): return {
        guard case .statusMsg(let l) = lhs, case .statusMsg(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.downloadMsg, .downloadMsg): return {
        guard case .downloadMsg(let l) = lhs, case .downloadMsg(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_DownloadMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var filename: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_StatusMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var msg: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// nothing
public struct Outlet_Backend_Daemon_Grpc_Generated_SendSignalResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_GetChildList_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var parentNode: Outlet_Backend_Daemon_Grpc_Generated_Node {
    get {return _parentNode ?? Outlet_Backend_Daemon_Grpc_Generated_Node()}
    set {_parentNode = newValue}
  }
  /// Returns true if `parentNode` has been explicitly set.
  public var hasParentNode: Bool {return self._parentNode != nil}
  /// Clears the value of `parentNode`. Subsequent reads from it will return its default value.
  public mutating func clearParentNode() {self._parentNode = nil}

  public var filterCriteria: Outlet_Backend_Daemon_Grpc_Generated_FilterCriteria {
    get {return _filterCriteria ?? Outlet_Backend_Daemon_Grpc_Generated_FilterCriteria()}
    set {_filterCriteria = newValue}
  }
  /// Returns true if `filterCriteria` has been explicitly set.
  public var hasFilterCriteria: Bool {return self._filterCriteria != nil}
  /// Clears the value of `filterCriteria`. Subsequent reads from it will return its default value.
  public mutating func clearFilterCriteria() {self._filterCriteria = nil}

  public var treeID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _parentNode: Outlet_Backend_Daemon_Grpc_Generated_Node? = nil
  fileprivate var _filterCriteria: Outlet_Backend_Daemon_Grpc_Generated_FilterCriteria? = nil
}

public struct Outlet_Backend_Daemon_Grpc_Generated_GetChildList_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nodeList: [Outlet_Backend_Daemon_Grpc_Generated_Node] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_GetAncestorList_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var spid: Outlet_Backend_Daemon_Grpc_Generated_NodeIdentifier {
    get {return _spid ?? Outlet_Backend_Daemon_Grpc_Generated_NodeIdentifier()}
    set {_spid = newValue}
  }
  /// Returns true if `spid` has been explicitly set.
  public var hasSpid: Bool {return self._spid != nil}
  /// Clears the value of `spid`. Subsequent reads from it will return its default value.
  public mutating func clearSpid() {self._spid = nil}

  public var stopAtPath: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _spid: Outlet_Backend_Daemon_Grpc_Generated_NodeIdentifier? = nil
}

public struct Outlet_Backend_Daemon_Grpc_Generated_GetAncestorList_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nodeList: [Outlet_Backend_Daemon_Grpc_Generated_Node] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_PlayState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var isEnabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_StartSubtreeLoad_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var treeID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// nothing
public struct Outlet_Backend_Daemon_Grpc_Generated_StartSubtreeLoad_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_DisplayTreeUiState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var treeID: String = String()

  public var rootSn: Outlet_Backend_Daemon_Grpc_Generated_SPIDNodePair {
    get {return _rootSn ?? Outlet_Backend_Daemon_Grpc_Generated_SPIDNodePair()}
    set {_rootSn = newValue}
  }
  /// Returns true if `rootSn` has been explicitly set.
  public var hasRootSn: Bool {return self._rootSn != nil}
  /// Clears the value of `rootSn`. Subsequent reads from it will return its default value.
  public mutating func clearRootSn() {self._rootSn = nil}

  public var rootExists: Bool = false

  public var offendingPath: String = String()

  public var needsManualLoad: Bool = false

  public var treeDisplayMode: UInt32 = 0

  public var hasCheckboxes_p: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _rootSn: Outlet_Backend_Daemon_Grpc_Generated_SPIDNodePair? = nil
}

public struct Outlet_Backend_Daemon_Grpc_Generated_RequestDisplayTree_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var isStartup: Bool = false

  public var treeID: String = String()

  public var returnAsync: Bool = false

  public var userPath: String = String()

  public var spid: Outlet_Backend_Daemon_Grpc_Generated_NodeIdentifier {
    get {return _spid ?? Outlet_Backend_Daemon_Grpc_Generated_NodeIdentifier()}
    set {_spid = newValue}
  }
  /// Returns true if `spid` has been explicitly set.
  public var hasSpid: Bool {return self._spid != nil}
  /// Clears the value of `spid`. Subsequent reads from it will return its default value.
  public mutating func clearSpid() {self._spid = nil}

  public var treeDisplayMode: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _spid: Outlet_Backend_Daemon_Grpc_Generated_NodeIdentifier? = nil
}

public struct Outlet_Backend_Daemon_Grpc_Generated_RequestDisplayTree_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var displayTreeUiState: Outlet_Backend_Daemon_Grpc_Generated_DisplayTreeUiState {
    get {return _displayTreeUiState ?? Outlet_Backend_Daemon_Grpc_Generated_DisplayTreeUiState()}
    set {_displayTreeUiState = newValue}
  }
  /// Returns true if `displayTreeUiState` has been explicitly set.
  public var hasDisplayTreeUiState: Bool {return self._displayTreeUiState != nil}
  /// Clears the value of `displayTreeUiState`. Subsequent reads from it will return its default value.
  public mutating func clearDisplayTreeUiState() {self._displayTreeUiState = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _displayTreeUiState: Outlet_Backend_Daemon_Grpc_Generated_DisplayTreeUiState? = nil
}

public struct Outlet_Backend_Daemon_Grpc_Generated_SingleNode_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var node: Outlet_Backend_Daemon_Grpc_Generated_Node {
    get {return _node ?? Outlet_Backend_Daemon_Grpc_Generated_Node()}
    set {_node = newValue}
  }
  /// Returns true if `node` has been explicitly set.
  public var hasNode: Bool {return self._node != nil}
  /// Clears the value of `node`. Subsequent reads from it will return its default value.
  public mutating func clearNode() {self._node = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _node: Outlet_Backend_Daemon_Grpc_Generated_Node? = nil
}

public struct Outlet_Backend_Daemon_Grpc_Generated_GetUidForLocalPath_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fullPath: String = String()

  public var uidSuggestion: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_GetUidForLocalPath_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_GetNodeForUid_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: UInt32 = 0

  /// optional
  public var treeType: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_GetNodeForLocalPath_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fullPath: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// nothing
public struct Outlet_Backend_Daemon_Grpc_Generated_GetNextUid_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Outlet_Backend_Daemon_Grpc_Generated_GetNextUid_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "outlet.backend.daemon.grpc.generated"

extension Outlet_Backend_Daemon_Grpc_Generated_Empty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Empty"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_Empty, rhs: Outlet_Backend_Daemon_Grpc_Generated_Empty) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_ConfigEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfigEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "val"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.val) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.val.isEmpty {
      try visitor.visitSingularStringField(value: self.val, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_ConfigEntry, rhs: Outlet_Backend_Daemon_Grpc_Generated_ConfigEntry) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.val != rhs.val {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_GetConfig_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetConfig_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "config_key_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.configKeyList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.configKeyList.isEmpty {
      try visitor.visitRepeatedStringField(value: self.configKeyList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_GetConfig_Request, rhs: Outlet_Backend_Daemon_Grpc_Generated_GetConfig_Request) -> Bool {
    if lhs.configKeyList != rhs.configKeyList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_GetConfig_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetConfig_Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "config_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.configList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.configList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.configList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_GetConfig_Response, rhs: Outlet_Backend_Daemon_Grpc_Generated_GetConfig_Response) -> Bool {
    if lhs.configList != rhs.configList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_PutConfig_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PutConfig_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "config_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.configList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.configList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.configList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_PutConfig_Request, rhs: Outlet_Backend_Daemon_Grpc_Generated_PutConfig_Request) -> Bool {
    if lhs.configList != rhs.configList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_PutConfig_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PutConfig_Response"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_PutConfig_Response, rhs: Outlet_Backend_Daemon_Grpc_Generated_PutConfig_Response) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_GetFilter_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFilter_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tree_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.treeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.treeID.isEmpty {
      try visitor.visitSingularStringField(value: self.treeID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_GetFilter_Request, rhs: Outlet_Backend_Daemon_Grpc_Generated_GetFilter_Request) -> Bool {
    if lhs.treeID != rhs.treeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_GetFilter_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFilter_Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "filter_criteria"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._filterCriteria) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._filterCriteria {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_GetFilter_Response, rhs: Outlet_Backend_Daemon_Grpc_Generated_GetFilter_Response) -> Bool {
    if lhs._filterCriteria != rhs._filterCriteria {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_UpdateFilter_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateFilter_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tree_id"),
    2: .standard(proto: "filter_criteria"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.treeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._filterCriteria) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.treeID.isEmpty {
      try visitor.visitSingularStringField(value: self.treeID, fieldNumber: 1)
    }
    if let v = self._filterCriteria {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_UpdateFilter_Request, rhs: Outlet_Backend_Daemon_Grpc_Generated_UpdateFilter_Request) -> Bool {
    if lhs.treeID != rhs.treeID {return false}
    if lhs._filterCriteria != rhs._filterCriteria {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_UpdateFilter_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateFilter_Response"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_UpdateFilter_Response, rhs: Outlet_Backend_Daemon_Grpc_Generated_UpdateFilter_Response) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_RemoveExpandedRow_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoveExpandedRow_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_uid"),
    2: .standard(proto: "tree_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.nodeUid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.treeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nodeUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.nodeUid, fieldNumber: 1)
    }
    if !self.treeID.isEmpty {
      try visitor.visitSingularStringField(value: self.treeID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_RemoveExpandedRow_Request, rhs: Outlet_Backend_Daemon_Grpc_Generated_RemoveExpandedRow_Request) -> Bool {
    if lhs.nodeUid != rhs.nodeUid {return false}
    if lhs.treeID != rhs.treeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_RemoveExpandedRow_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoveExpandedRow_Response"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_RemoveExpandedRow_Response, rhs: Outlet_Backend_Daemon_Grpc_Generated_RemoveExpandedRow_Response) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_GetRowsOfInterest_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRowsOfInterest_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tree_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.treeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.treeID.isEmpty {
      try visitor.visitSingularStringField(value: self.treeID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_GetRowsOfInterest_Request, rhs: Outlet_Backend_Daemon_Grpc_Generated_GetRowsOfInterest_Request) -> Bool {
    if lhs.treeID != rhs.treeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_GetRowsOfInterest_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRowsOfInterest_Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "expanded_row_uid_set"),
    2: .standard(proto: "selected_row_uid_set"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt32Field(value: &self.expandedRowUidSet) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.selectedRowUidSet) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.expandedRowUidSet.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.expandedRowUidSet, fieldNumber: 1)
    }
    if !self.selectedRowUidSet.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.selectedRowUidSet, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_GetRowsOfInterest_Response, rhs: Outlet_Backend_Daemon_Grpc_Generated_GetRowsOfInterest_Response) -> Bool {
    if lhs.expandedRowUidSet != rhs.expandedRowUidSet {return false}
    if lhs.selectedRowUidSet != rhs.selectedRowUidSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_GetLastPendingOp_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLastPendingOp_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.nodeUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nodeUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.nodeUid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_GetLastPendingOp_Request, rhs: Outlet_Backend_Daemon_Grpc_Generated_GetLastPendingOp_Request) -> Bool {
    if lhs.nodeUid != rhs.nodeUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_DownloadFromGDrive_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DownloadFromGDrive_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_uid"),
    2: .standard(proto: "requestor_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.nodeUid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.requestorID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nodeUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.nodeUid, fieldNumber: 1)
    }
    if !self.requestorID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestorID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_DownloadFromGDrive_Request, rhs: Outlet_Backend_Daemon_Grpc_Generated_DownloadFromGDrive_Request) -> Bool {
    if lhs.nodeUid != rhs.nodeUid {return false}
    if lhs.requestorID != rhs.requestorID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_GetLastPendingOp_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLastPendingOp_Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_op"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userOp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._userOp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_GetLastPendingOp_Response, rhs: Outlet_Backend_Daemon_Grpc_Generated_GetLastPendingOp_Response) -> Bool {
    if lhs._userOp != rhs._userOp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_Subscribe_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Subscribe_Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_Subscribe_Request, rhs: Outlet_Backend_Daemon_Grpc_Generated_Subscribe_Request) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_GetOpExecPlayState_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOpExecPlayState_Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_GetOpExecPlayState_Request, rhs: Outlet_Backend_Daemon_Grpc_Generated_GetOpExecPlayState_Request) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_ToggleUiEnablement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToggleUiEnablement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enable != false {
      try visitor.visitSingularBoolField(value: self.enable, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_ToggleUiEnablement, rhs: Outlet_Backend_Daemon_Grpc_Generated_ToggleUiEnablement) -> Bool {
    if lhs.enable != rhs.enable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_GenerateMergeTree_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateMergeTree_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tree_id_left"),
    2: .standard(proto: "tree_id_right"),
    3: .standard(proto: "change_list_left"),
    4: .standard(proto: "change_list_right"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.treeIDLeft) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.treeIDRight) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.changeListLeft) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.changeListRight) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.treeIDLeft.isEmpty {
      try visitor.visitSingularStringField(value: self.treeIDLeft, fieldNumber: 1)
    }
    if !self.treeIDRight.isEmpty {
      try visitor.visitSingularStringField(value: self.treeIDRight, fieldNumber: 2)
    }
    if !self.changeListLeft.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.changeListLeft, fieldNumber: 3)
    }
    if !self.changeListRight.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.changeListRight, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_GenerateMergeTree_Request, rhs: Outlet_Backend_Daemon_Grpc_Generated_GenerateMergeTree_Request) -> Bool {
    if lhs.treeIDLeft != rhs.treeIDLeft {return false}
    if lhs.treeIDRight != rhs.treeIDRight {return false}
    if lhs.changeListLeft != rhs.changeListLeft {return false}
    if lhs.changeListRight != rhs.changeListRight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_DragDrop_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DragDrop_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "src_tree_id"),
    2: .standard(proto: "dst_tree_id"),
    3: .standard(proto: "src_sn_list"),
    4: .standard(proto: "dst_sn"),
    5: .standard(proto: "is_into"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.srcTreeID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.dstTreeID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.srcSnList) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._dstSn) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isInto) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.srcTreeID.isEmpty {
      try visitor.visitSingularStringField(value: self.srcTreeID, fieldNumber: 1)
    }
    if !self.dstTreeID.isEmpty {
      try visitor.visitSingularStringField(value: self.dstTreeID, fieldNumber: 2)
    }
    if !self.srcSnList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.srcSnList, fieldNumber: 3)
    }
    if let v = self._dstSn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.isInto != false {
      try visitor.visitSingularBoolField(value: self.isInto, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_DragDrop_Request, rhs: Outlet_Backend_Daemon_Grpc_Generated_DragDrop_Request) -> Bool {
    if lhs.srcTreeID != rhs.srcTreeID {return false}
    if lhs.dstTreeID != rhs.dstTreeID {return false}
    if lhs.srcSnList != rhs.srcSnList {return false}
    if lhs._dstSn != rhs._dstSn {return false}
    if lhs.isInto != rhs.isInto {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_RefreshSubtree_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RefreshSubtree_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_identifier"),
    2: .standard(proto: "tree_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nodeIdentifier) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.treeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._nodeIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.treeID.isEmpty {
      try visitor.visitSingularStringField(value: self.treeID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_RefreshSubtree_Request, rhs: Outlet_Backend_Daemon_Grpc_Generated_RefreshSubtree_Request) -> Bool {
    if lhs._nodeIdentifier != rhs._nodeIdentifier {return false}
    if lhs.treeID != rhs.treeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_RefreshSubtreeStats_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RefreshSubtreeStats_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_uid"),
    2: .standard(proto: "tree_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.rootUid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.treeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rootUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.rootUid, fieldNumber: 1)
    }
    if !self.treeID.isEmpty {
      try visitor.visitSingularStringField(value: self.treeID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_RefreshSubtreeStats_Request, rhs: Outlet_Backend_Daemon_Grpc_Generated_RefreshSubtreeStats_Request) -> Bool {
    if lhs.rootUid != rhs.rootUid {return false}
    if lhs.treeID != rhs.treeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_DeleteSubtree_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteSubtree_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_uid_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt32Field(value: &self.nodeUidList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeUidList.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.nodeUidList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_DeleteSubtree_Request, rhs: Outlet_Backend_Daemon_Grpc_Generated_DeleteSubtree_Request) -> Bool {
    if lhs.nodeUidList != rhs.nodeUidList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_ErrorOccurred: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ErrorOccurred"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msg"),
    2: .standard(proto: "secondary_msg"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.secondaryMsg) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 1)
    }
    if !self.secondaryMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.secondaryMsg, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_ErrorOccurred, rhs: Outlet_Backend_Daemon_Grpc_Generated_ErrorOccurred) -> Bool {
    if lhs.msg != rhs.msg {return false}
    if lhs.secondaryMsg != rhs.secondaryMsg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_UidContainer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UidContainer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.uid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularUInt32Field(value: self.uid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_UidContainer, rhs: Outlet_Backend_Daemon_Grpc_Generated_UidContainer) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_StartDiffTrees_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartDiffTrees_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tree_id_left"),
    2: .standard(proto: "tree_id_right"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.treeIDLeft) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.treeIDRight) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.treeIDLeft.isEmpty {
      try visitor.visitSingularStringField(value: self.treeIDLeft, fieldNumber: 1)
    }
    if !self.treeIDRight.isEmpty {
      try visitor.visitSingularStringField(value: self.treeIDRight, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_StartDiffTrees_Request, rhs: Outlet_Backend_Daemon_Grpc_Generated_StartDiffTrees_Request) -> Bool {
    if lhs.treeIDLeft != rhs.treeIDLeft {return false}
    if lhs.treeIDRight != rhs.treeIDRight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_StartDiffTrees_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartDiffTrees_Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tree_id_left"),
    2: .standard(proto: "tree_id_right"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.treeIDLeft) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.treeIDRight) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.treeIDLeft.isEmpty {
      try visitor.visitSingularStringField(value: self.treeIDLeft, fieldNumber: 1)
    }
    if !self.treeIDRight.isEmpty {
      try visitor.visitSingularStringField(value: self.treeIDRight, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_StartDiffTrees_Response, rhs: Outlet_Backend_Daemon_Grpc_Generated_StartDiffTrees_Response) -> Bool {
    if lhs.treeIDLeft != rhs.treeIDLeft {return false}
    if lhs.treeIDRight != rhs.treeIDRight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_DragDrop_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DragDrop_Response"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_DragDrop_Response, rhs: Outlet_Backend_Daemon_Grpc_Generated_DragDrop_Response) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_SignalMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignalMsg"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sig_int"),
    2: .same(proto: "sender"),
    10: .same(proto: "empty"),
    11: .standard(proto: "error_occurred"),
    12: .standard(proto: "display_tree_ui_state"),
    13: .standard(proto: "play_state"),
    14: .standard(proto: "ui_enablement"),
    15: .same(proto: "node"),
    16: .standard(proto: "src_dst_node_list"),
    17: .standard(proto: "status_msg"),
    18: .standard(proto: "download_msg"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.sigInt) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 10: try {
        var v: Outlet_Backend_Daemon_Grpc_Generated_Empty?
        if let current = self.signalData {
          try decoder.handleConflictingOneOf()
          if case .empty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.signalData = .empty(v)}
      }()
      case 11: try {
        var v: Outlet_Backend_Daemon_Grpc_Generated_ErrorOccurred?
        if let current = self.signalData {
          try decoder.handleConflictingOneOf()
          if case .errorOccurred(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.signalData = .errorOccurred(v)}
      }()
      case 12: try {
        var v: Outlet_Backend_Daemon_Grpc_Generated_DisplayTreeUiState?
        if let current = self.signalData {
          try decoder.handleConflictingOneOf()
          if case .displayTreeUiState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.signalData = .displayTreeUiState(v)}
      }()
      case 13: try {
        var v: Outlet_Backend_Daemon_Grpc_Generated_PlayState?
        if let current = self.signalData {
          try decoder.handleConflictingOneOf()
          if case .playState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.signalData = .playState(v)}
      }()
      case 14: try {
        var v: Outlet_Backend_Daemon_Grpc_Generated_ToggleUiEnablement?
        if let current = self.signalData {
          try decoder.handleConflictingOneOf()
          if case .uiEnablement(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.signalData = .uiEnablement(v)}
      }()
      case 15: try {
        var v: Outlet_Backend_Daemon_Grpc_Generated_Node?
        if let current = self.signalData {
          try decoder.handleConflictingOneOf()
          if case .node(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.signalData = .node(v)}
      }()
      case 16: try {
        var v: Outlet_Backend_Daemon_Grpc_Generated_SrcDstNodeList?
        if let current = self.signalData {
          try decoder.handleConflictingOneOf()
          if case .srcDstNodeList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.signalData = .srcDstNodeList(v)}
      }()
      case 17: try {
        var v: Outlet_Backend_Daemon_Grpc_Generated_StatusMsg?
        if let current = self.signalData {
          try decoder.handleConflictingOneOf()
          if case .statusMsg(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.signalData = .statusMsg(v)}
      }()
      case 18: try {
        var v: Outlet_Backend_Daemon_Grpc_Generated_DownloadMsg?
        if let current = self.signalData {
          try decoder.handleConflictingOneOf()
          if case .downloadMsg(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.signalData = .downloadMsg(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sigInt != 0 {
      try visitor.visitSingularUInt32Field(value: self.sigInt, fieldNumber: 1)
    }
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.signalData {
    case .empty?: try {
      guard case .empty(let v)? = self.signalData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .errorOccurred?: try {
      guard case .errorOccurred(let v)? = self.signalData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .displayTreeUiState?: try {
      guard case .displayTreeUiState(let v)? = self.signalData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .playState?: try {
      guard case .playState(let v)? = self.signalData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .uiEnablement?: try {
      guard case .uiEnablement(let v)? = self.signalData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .node?: try {
      guard case .node(let v)? = self.signalData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .srcDstNodeList?: try {
      guard case .srcDstNodeList(let v)? = self.signalData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .statusMsg?: try {
      guard case .statusMsg(let v)? = self.signalData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .downloadMsg?: try {
      guard case .downloadMsg(let v)? = self.signalData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_SignalMsg, rhs: Outlet_Backend_Daemon_Grpc_Generated_SignalMsg) -> Bool {
    if lhs.sigInt != rhs.sigInt {return false}
    if lhs.sender != rhs.sender {return false}
    if lhs.signalData != rhs.signalData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_DownloadMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DownloadMsg"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filename"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.filename) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filename.isEmpty {
      try visitor.visitSingularStringField(value: self.filename, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_DownloadMsg, rhs: Outlet_Backend_Daemon_Grpc_Generated_DownloadMsg) -> Bool {
    if lhs.filename != rhs.filename {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_StatusMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatusMsg"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msg"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_StatusMsg, rhs: Outlet_Backend_Daemon_Grpc_Generated_StatusMsg) -> Bool {
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_SendSignalResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendSignalResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_SendSignalResponse, rhs: Outlet_Backend_Daemon_Grpc_Generated_SendSignalResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_GetChildList_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChildList_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parent_node"),
    2: .standard(proto: "filter_criteria"),
    3: .standard(proto: "tree_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._parentNode) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._filterCriteria) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.treeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._parentNode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._filterCriteria {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.treeID.isEmpty {
      try visitor.visitSingularStringField(value: self.treeID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_GetChildList_Request, rhs: Outlet_Backend_Daemon_Grpc_Generated_GetChildList_Request) -> Bool {
    if lhs._parentNode != rhs._parentNode {return false}
    if lhs._filterCriteria != rhs._filterCriteria {return false}
    if lhs.treeID != rhs.treeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_GetChildList_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChildList_Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodeList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodeList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_GetChildList_Response, rhs: Outlet_Backend_Daemon_Grpc_Generated_GetChildList_Response) -> Bool {
    if lhs.nodeList != rhs.nodeList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_GetAncestorList_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAncestorList_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "spid"),
    2: .standard(proto: "stop_at_path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._spid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.stopAtPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._spid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.stopAtPath.isEmpty {
      try visitor.visitSingularStringField(value: self.stopAtPath, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_GetAncestorList_Request, rhs: Outlet_Backend_Daemon_Grpc_Generated_GetAncestorList_Request) -> Bool {
    if lhs._spid != rhs._spid {return false}
    if lhs.stopAtPath != rhs.stopAtPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_GetAncestorList_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAncestorList_Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodeList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodeList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_GetAncestorList_Response, rhs: Outlet_Backend_Daemon_Grpc_Generated_GetAncestorList_Response) -> Bool {
    if lhs.nodeList != rhs.nodeList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_PlayState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlayState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isEnabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isEnabled != false {
      try visitor.visitSingularBoolField(value: self.isEnabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_PlayState, rhs: Outlet_Backend_Daemon_Grpc_Generated_PlayState) -> Bool {
    if lhs.isEnabled != rhs.isEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_StartSubtreeLoad_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartSubtreeLoad_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tree_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.treeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.treeID.isEmpty {
      try visitor.visitSingularStringField(value: self.treeID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_StartSubtreeLoad_Request, rhs: Outlet_Backend_Daemon_Grpc_Generated_StartSubtreeLoad_Request) -> Bool {
    if lhs.treeID != rhs.treeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_StartSubtreeLoad_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartSubtreeLoad_Response"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_StartSubtreeLoad_Response, rhs: Outlet_Backend_Daemon_Grpc_Generated_StartSubtreeLoad_Response) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_DisplayTreeUiState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DisplayTreeUiState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tree_id"),
    2: .standard(proto: "root_sn"),
    3: .standard(proto: "root_exists"),
    4: .standard(proto: "offending_path"),
    5: .standard(proto: "needs_manual_load"),
    6: .standard(proto: "tree_display_mode"),
    7: .standard(proto: "has_checkboxes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.treeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rootSn) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.rootExists) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.offendingPath) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.needsManualLoad) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.treeDisplayMode) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.hasCheckboxes_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.treeID.isEmpty {
      try visitor.visitSingularStringField(value: self.treeID, fieldNumber: 1)
    }
    if let v = self._rootSn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.rootExists != false {
      try visitor.visitSingularBoolField(value: self.rootExists, fieldNumber: 3)
    }
    if !self.offendingPath.isEmpty {
      try visitor.visitSingularStringField(value: self.offendingPath, fieldNumber: 4)
    }
    if self.needsManualLoad != false {
      try visitor.visitSingularBoolField(value: self.needsManualLoad, fieldNumber: 5)
    }
    if self.treeDisplayMode != 0 {
      try visitor.visitSingularUInt32Field(value: self.treeDisplayMode, fieldNumber: 6)
    }
    if self.hasCheckboxes_p != false {
      try visitor.visitSingularBoolField(value: self.hasCheckboxes_p, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_DisplayTreeUiState, rhs: Outlet_Backend_Daemon_Grpc_Generated_DisplayTreeUiState) -> Bool {
    if lhs.treeID != rhs.treeID {return false}
    if lhs._rootSn != rhs._rootSn {return false}
    if lhs.rootExists != rhs.rootExists {return false}
    if lhs.offendingPath != rhs.offendingPath {return false}
    if lhs.needsManualLoad != rhs.needsManualLoad {return false}
    if lhs.treeDisplayMode != rhs.treeDisplayMode {return false}
    if lhs.hasCheckboxes_p != rhs.hasCheckboxes_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_RequestDisplayTree_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestDisplayTree_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_startup"),
    2: .standard(proto: "tree_id"),
    3: .standard(proto: "return_async"),
    4: .standard(proto: "user_path"),
    5: .same(proto: "spid"),
    6: .standard(proto: "tree_display_mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isStartup) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.treeID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.returnAsync) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.userPath) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._spid) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.treeDisplayMode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isStartup != false {
      try visitor.visitSingularBoolField(value: self.isStartup, fieldNumber: 1)
    }
    if !self.treeID.isEmpty {
      try visitor.visitSingularStringField(value: self.treeID, fieldNumber: 2)
    }
    if self.returnAsync != false {
      try visitor.visitSingularBoolField(value: self.returnAsync, fieldNumber: 3)
    }
    if !self.userPath.isEmpty {
      try visitor.visitSingularStringField(value: self.userPath, fieldNumber: 4)
    }
    if let v = self._spid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if self.treeDisplayMode != 0 {
      try visitor.visitSingularUInt32Field(value: self.treeDisplayMode, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_RequestDisplayTree_Request, rhs: Outlet_Backend_Daemon_Grpc_Generated_RequestDisplayTree_Request) -> Bool {
    if lhs.isStartup != rhs.isStartup {return false}
    if lhs.treeID != rhs.treeID {return false}
    if lhs.returnAsync != rhs.returnAsync {return false}
    if lhs.userPath != rhs.userPath {return false}
    if lhs._spid != rhs._spid {return false}
    if lhs.treeDisplayMode != rhs.treeDisplayMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_RequestDisplayTree_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestDisplayTree_Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "display_tree_ui_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._displayTreeUiState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._displayTreeUiState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_RequestDisplayTree_Response, rhs: Outlet_Backend_Daemon_Grpc_Generated_RequestDisplayTree_Response) -> Bool {
    if lhs._displayTreeUiState != rhs._displayTreeUiState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_SingleNode_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SingleNode_Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "node"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._node) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._node {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_SingleNode_Response, rhs: Outlet_Backend_Daemon_Grpc_Generated_SingleNode_Response) -> Bool {
    if lhs._node != rhs._node {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_GetUidForLocalPath_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUidForLocalPath_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "full_path"),
    2: .standard(proto: "uid_suggestion"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fullPath) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.uidSuggestion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fullPath.isEmpty {
      try visitor.visitSingularStringField(value: self.fullPath, fieldNumber: 1)
    }
    if self.uidSuggestion != 0 {
      try visitor.visitSingularUInt32Field(value: self.uidSuggestion, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_GetUidForLocalPath_Request, rhs: Outlet_Backend_Daemon_Grpc_Generated_GetUidForLocalPath_Request) -> Bool {
    if lhs.fullPath != rhs.fullPath {return false}
    if lhs.uidSuggestion != rhs.uidSuggestion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_GetUidForLocalPath_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUidForLocalPath_Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.uid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularUInt32Field(value: self.uid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_GetUidForLocalPath_Response, rhs: Outlet_Backend_Daemon_Grpc_Generated_GetUidForLocalPath_Response) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_GetNodeForUid_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNodeForUid_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .standard(proto: "tree_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.treeType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularUInt32Field(value: self.uid, fieldNumber: 1)
    }
    if self.treeType != 0 {
      try visitor.visitSingularUInt32Field(value: self.treeType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_GetNodeForUid_Request, rhs: Outlet_Backend_Daemon_Grpc_Generated_GetNodeForUid_Request) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.treeType != rhs.treeType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_GetNodeForLocalPath_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNodeForLocalPath_Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "full_path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fullPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fullPath.isEmpty {
      try visitor.visitSingularStringField(value: self.fullPath, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_GetNodeForLocalPath_Request, rhs: Outlet_Backend_Daemon_Grpc_Generated_GetNodeForLocalPath_Request) -> Bool {
    if lhs.fullPath != rhs.fullPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_GetNextUid_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNextUid_Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_GetNextUid_Request, rhs: Outlet_Backend_Daemon_Grpc_Generated_GetNextUid_Request) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Outlet_Backend_Daemon_Grpc_Generated_GetNextUid_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNextUid_Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.uid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularUInt32Field(value: self.uid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Outlet_Backend_Daemon_Grpc_Generated_GetNextUid_Response, rhs: Outlet_Backend_Daemon_Grpc_Generated_GetNextUid_Response) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
